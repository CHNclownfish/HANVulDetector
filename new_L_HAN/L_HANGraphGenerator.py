import networkx as nx
import matplotlib.pyplot as plt
import torch as th
import dgl
import json

# generator accept a list of dot file as input, return a dgl format heterogenous graph
# where graphGenerator_ethersolve for dot file generated by ethersolve, i.e bytecode cfg
# and  class graphGenerator_slither for dot file generated by slither i.e sourcecode cfg

class graphGenerator_ethersolve:
    def __init__(self, dotfilepaths):
        self.node2oneHot = {}
        g = nx.drawing.nx_pydot.read_dot(dotfilepaths[0])
        for i in range(1, len(dotfilepaths)):
            new_g = nx.drawing.nx_pydot.read_dot(dotfilepaths[i])
            g = nx.algorithms.operators.binary.disjoint_union(g, new_g)
        self.g = g
        self.d = {('None', 'None', 'None'): '0', ('None', 'None', 'orange'): '1', ('Msquare', 'None', 'gold'): '2',
                  ('None', 'None', 'lemonchiffon'): '3', ('Msquare', 'crimson', 'crimson'): '4', ('None', 'None', 'crimson'):
                      '5', ('Msquare', 'crimson', 'None'): '6', ('Msquare', 'crimson', 'lemonchiffon'): '7'}
        for i in range(8):
            self.node2oneHot[str(i)] = [0 for _ in range(8)]
            self.node2oneHot[str(i)][i] = 1

    # return two hash map where int2label -> {node_idx: 'node_type'}, and edgeLabel -> {(node_idx0, node_idx1 : 'edge_type)}
    def createLabel(self):
        nodes = self.g.nodes()
        int2label = {}
        startwith, endwith = 0,1
        node_info = {}
        edgeLabel = {}
        for idx, node_idx in enumerate(nodes):
            obj = self.g._node[node_idx]
            if 'shape' not in obj:
                shape = 'None'
            else:
                shape = obj['shape']
            if 'color' not in obj:
                color = 'None'
            else:
                color = obj['color']
            if 'fillcolor' not in obj:
                fillcolor = 'None'
            else:
                fillcolor = obj['fillcolor']
            t = (shape,color,fillcolor)
            node_type = self.d[t]
            # nodetype without number
            # psb_node_type = g._node[node_idx]['label'].splitlines()[0]
            # colonPos = psb_node_type.find(':') + 1
            # node_type = psb_node_type[colonPos:]
            int2label[node_idx] = node_type
            #print(node_idx,node_type)

            info = obj['label'].split(':')
            node_info[node_idx] = [info[1][1:9], info[-1][1:-3]]

        for u, v in self.g.edges():
            if node_info[u][endwith] == 'JUMPI':
                if node_info[v][startwith] == 'JUMPDEST':
                    edgeLabel[(u,v)] = 'True'
                else:
                    edgeLabel[(u,v)] = 'False'
            else:
                edgeLabel[(u,v)] = 'CF'


        return int2label, edgeLabel

    def graphVision(self):
        nodesLabel,edgeLabel = self.createLabel()
        pos = nx.spring_layout(self.g)

        nx.draw_networkx_labels(self.g, pos, nodesLabel, font_size=6, font_color="black")
        nx.draw_networkx_edge_labels(self.g,pos,edgeLabel, font_size=6,font_color="black")
        nx.draw(self.g,pos)
        plt.show()


    def createHeteroGraph(self):
        candiGraphData = {}
        graphdata = {}
        nodesLabel,edgeLabel = self.createLabel()
        u_vector, v_vector = 0, 1
        for u, v in self.g.edges():
            e_type = edgeLabel[(u,v)]

            if (nodesLabel[u],e_type,nodesLabel[v]) not in candiGraphData:
                candiGraphData[(nodesLabel[u],e_type,nodesLabel[v])] = [[int(u)],[int(v)]]
            else:
                candiGraphData[(nodesLabel[u],e_type,nodesLabel[v])][u_vector].append(int(u))
                candiGraphData[(nodesLabel[u],e_type,nodesLabel[v])][v_vector].append(int(v))
            for key in candiGraphData:
                u = candiGraphData[key][u_vector]
                v = candiGraphData[key][v_vector]
                graphdata[key] = (th.tensor(u),th.tensor(v))
        dg = dgl.heterograph(graphdata)

        return dg

    # return a dgl heterogenous graph
    def reflectHeteroGraph(self):
        candiGraphData = {}
        graphdata = {}
        nodesLabel, edgeLabel = self.createLabel()
        u_vector, v_vector = 0, 1
        nodeslabelback = {}
        for idx in nodesLabel:
            node_type = nodesLabel[idx]
            if node_type not in nodeslabelback:
                nodeslabelback[node_type] = [idx]
            else:
                nodeslabelback[node_type].append(idx)
        nodeidx2nodeidx = {}
        for node_type in nodeslabelback:
            for id, node in enumerate(nodeslabelback[node_type]):
                nodeidx2nodeidx[node] = id
        for u,v in self.g.edges():
            e_type = edgeLabel[(u,v)]
            if (nodesLabel[u], e_type, nodesLabel[v]) not in candiGraphData:
                candiGraphData[(nodesLabel[u],e_type,nodesLabel[v])] = [[nodeidx2nodeidx[u]],[nodeidx2nodeidx[v]]]
            else:
                candiGraphData[(nodesLabel[u],e_type,nodesLabel[v])][u_vector].append(nodeidx2nodeidx[u])
                candiGraphData[(nodesLabel[u],e_type,nodesLabel[v])][v_vector].append(nodeidx2nodeidx[v])
        for key in candiGraphData:
            u = candiGraphData[key][u_vector]
            v = candiGraphData[key][v_vector]
            graphdata[key] = (th.tensor(u),th.tensor(v))
            sn, e, en = key
            new_e = e[::-1]
            new_k = (en,new_e,sn)
            graphdata[new_k] = (th.tensor(v),th.tensor(u))
        dg = dgl.heterograph(graphdata)

        for node in dg.ntypes:
            n = dg.num_nodes(node)
            l = [self.node2oneHot[node] for _ in range(n)]
            dg.nodes[node].data['f'] = th.tensor(l).float()

        return dg
